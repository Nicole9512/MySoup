Databse
===============

## 一、数据库设计优化目的
* 减少数据冗余
* 避免数据维护异常
* 节约存储空间
* 高效的访问（最重要）

## 二、逻辑关系

* 一对一、一对多、多对多

## 三、名词解释
__关系__：一个关系对应通常说的一张表。<br>
__元组__：表中的一行即是一个元组。<br>
__属性__：表中的一列即为一个属性；每个属性都有一个属性名称，称为属性名。<br>
__候选码__：表中的某个属性组，它可以确定唯一的一个元组。<br>
__主码__：一个关系对应多个候选码，选中其中一个作为主码。<br>
__分量__：元组的一个属性值。<br>

## 四.数据库异常操作和范式

* 常见的数据库范式有：第一、二、三和BC范式。

### 1.第一范式
* 定义：数据库表的所有字段都是单一属性，不可再分的。这个单一属性是由基本数据类型所构成的，如整数，浮点数，字符串等。换句话说，第一范式要求所有表都是二维表。
* 例如：这个设计，不符合第一范式。可以把用户信息中的属性再拆分满足第一范式。

|id|account|age|user_info|
|:--:|:--:|:--:|:--|
|1|zhang3|22|姓名：张三；电话137777|

### 2.第二范式
* 定义：数据库的表中不存在非关键字对任一候选关键字的部分函数依赖。部分函数依赖是指存在着组合关键字中的某一关键字决定非关键字的情况。换句话说，所有的单关键字段的表都符合第二范式。

* 例如：这个设计，不符合第二范式。可以通过建立三张表来使其满足第二范式（商品信息，供应商信息，商品-供应商关系表）

|product_name|supplier_name|price|descripition|weight|supplier_phone|shelf_life|category|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|可乐|饮料一厂|2.00|碳酸饮料|250g|8008200|2019-01|饮料

* 因为供应商和商品之间是多对多关系，所以只有使用商品名+供应商名才可以标识出一件商品。也就是说商品名+供应商名是一组组合关键字。上表中存在以下部分函数依赖：
>（商品名称） -> （价格，描述，重量，保质期）   
>（供应商名称） -> （供应商电话）

### 3.第三范式
* 定义：第三范式是在第二范式的基础上定义的，如果数据表中不存在非关键字字段对任意的候选关键字段的传递函数依赖则符合第三范式。

* 例如：存在以下函数依赖关系：
    > 商品名称 -> 分类 -> 分类描述   
* 也就是说存在非关键字字段“分类描述”对关键字字段"商品名称"产生传递函数依赖。

|product_name|price|descripition|weight|shelf_life|category|category_comment|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|可乐|2.00|快乐水|500g|2019-1|酒水饮料|碳酸饮料|
|苹果|3.00||200g|2017-10|水果生鲜|水果|

### 4.BC范式
* 定义：在第三范式的基础之上，数据库表中如果不存在任意字段对任一候选关键字段的传递函数依赖，则符合BC范式。也就说，如果是符合关键字，关键字之间也不能存在函数依赖。

## 五、优化方案
#### 1.定长与变长分离（char varchar）
#### 2.大型数据分离，用主键约束（text）
#### 3.常用字段和不常用字段可以分离，比如（用户表的身份证号等）
#### 4.允许适当的冗余字段，减少join
#### 5.优先存储整型（tinyint > int > datetime > enum, char > varchar > blob, text），考虑字符集和校对集（排序规则，比如 a b C D，大小的消毒出发，Ascii码来看，C < D < a < b），text/blob因为不能使用内存临时表，所以使用磁盘排序，超级慢。
#### 6.尽量不使用NULL，因为NULL不利于索引，要用特殊的字节来标识，在磁盘上占用的空间也更大。WHERE字句中，cols = NULL / cols != NULL，都查询不到NULL，只有使用IS NULL或者IS NOT NULL 才行。
#### 7.主从数据库（读写分离）
#### 8.分表

## 六、索引
* 索引是一种可以高效查询的数据结构。主要是B+TREE和HASH索引。
* 当order by 中的字段出现在where条件中时，才会利用索引而不排序，更准确的说，order by 中的字段在执行计划中利用了索引时，不用排序操作。 

#### 1.B-TREE
* 其实就是一颗二叉平衡树

#### 2.HASH
* 目前MySql中，只能使用在memory表中。
* 粗略的来说，HASH通过映射，反馈一个数据，例如这样：
```
def hash(id)
    return address
# 这样在查找时，每次查询计算HASH的地址，便可以直接找到数据。
```
* 但是HASH的缺点也是很明显的：<br>
1.HASH散列计算的结果是随机的，如果是在磁盘上放置数据，以主键id为例，`4, 5, 6` 计算的HASH值不一定是连续的，这样就会造成大量的内存空洞。<br>
2.无法利用范围查询。`WHERE id > 4`，原理同1。<br>
3.无法利用前缀索引。例如LIKE子句，B+TREE可以利用一部分的索引页，但是HASH来说，hash('hello')与hash('helloworld')结果仍然是完全随机没有关联的。
4.排序无法优化。
5.必须回行，也就是说，通过索引拿数据位置，必须回到表中取数据。

#### 3.B-TREE索引的常见误区
1.在WHERE条件常用列都加上INDEX。因为独立的索引，同时只能使用一个。
2.遵循左前缀原则。
3.联合索引顺序原则。

#### 4.聚簇索引和非聚簇索引
* InnoDb这样，主键的索引结构中，既存储了主键值，又存储了行信息，这种结构叫做 __聚簇索引__。其优势明显：根据主键查询条目计较少的时候，不用回行。劣势是：如果遇见不规则的数据插入时候，会频繁的造成页分裂。
* MyISAM索引是非聚簇索引，而innoDb是聚簇索引。

#### 5.索引覆盖
* 索引覆盖是指如果查询的列恰好是索引的一部分，那么只需在索引文件上进行，不需要回行到磁盘查找数据。

#### 6.理想索引
* 1.查询频繁 2.区分度高 3.长度小（与区分度高相矛盾）

#### 7.伪哈希索引
* 例如，crc32算法将字符串计算为整型，在整型列上加索引。

#### 8.修复表
* 一张频繁更新的表，会产生磁盘空洞，需要optimize + 表名，来修复。

## 七、MyISAM

* MyISAM的主索引和次索引都指向物理行（在磁盘中的位置）。
* 一个MySql的MyISAM表，例如news，实际上分三个文件存储:<br>
news.frm（用来存储数据表的元数据信息，包括表结构定义等）<br>
news.myd（用来存储数据信息）<br>
news.myi（用来存储索引）<br>
因此，MyISAM引擎的表，在使用索引时候需要回行（使用索引后，根据索引回.myd文件查找）。

## 八、InnoDb

* InnoDb的主索引文件存储该行数据，次索引指向对主键的引用。
* InnoDb的索引指向对主键的引用。主键索引既存储索引值，又会在叶子中存储行的数据。如果没有主键(primary key)，那么会使用unique key做主键。如果连unique key 都没有，那么内部会生成一个rowid做主键。
* 对InnoDb建立索引以后，每个数据的信息都在其代表索引（或者主键）的叶子下，所以不需要回行。


